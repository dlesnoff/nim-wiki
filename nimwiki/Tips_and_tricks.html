<!DOCTYPE html>
<html lang="en-us">
<head>
  <title>nimwiki/Tips_and_tricks.nim</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2280%22>üê≥</text></svg>">
  <meta content="text/html; charset=utf-8" http-equiv="content-type">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <link rel='stylesheet' href='https://unpkg.com/normalize.css'>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/light.min.css">
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/gh/pietroppeter/nimib/assets/atom-one-light.css'>
  <style>
.nb-box {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.nb-small {
  font-size: 0.8rem;
}
button.nb-small {
  float: right;
  padding: 2px;
  padding-right: 5px;
  padding-left: 5px;
}
section#source {
  display:none
}

.nb-output {
  line-height: 1.15;
}
</style>
  
</head>
<body>
<header>
<div class="nb-box">
  <span><a href="..">üè°</a></span>
  <span><code>nimwiki/Tips_and_tricks.nim</code></span>
  <span><a href="https://github.com/dlesnoff/nim-wiki"><svg aria-hidden="true" width="1.2em" height="1.2em" style="vertical-align: middle;" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59c.4.07.55-.17.55-.38c0-.19-.01-.82-.01-1.49c-2.01.37-2.53-.49-2.69-.94c-.09-.23-.48-.94-.82-1.13c-.28-.15-.68-.52-.01-.53c.63-.01 1.08.58 1.23.82c.72 1.21 1.87.87 2.33.66c.07-.52.28-.87.51-1.07c-1.78-.2-3.64-.89-3.64-3.95c0-.87.31-1.59.82-2.15c-.08-.2-.36-1.02.08-2.12c0 0 .67-.21 2.2.82c.64-.18 1.32-.27 2-.27c.68 0 1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82c.44 1.1.16 1.92.08 2.12c.51.56.82 1.27.82 2.15c0 3.07-1.87 3.75-3.65 3.95c.29.25.54.73.54 1.48c0 1.07-.01 1.93-.01 2.2c0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z" fill="#000"></path></svg></a></span>
</div>
<hr>
</header><main>
<h1>Nim Tips and tricks</h1>
<p>A mix of bits of code, cookbook recipes, deep knowledge, tips and tricks about Nim programming.</p>
<h2>Compilation</h2>
<h3>Syntax</h3>
<h4>Check syntax</h4>
<p>Use <code>nim check myfile.nim</code> to check your program for errors, without code generation. This makes the process quicker. Also, <code>nim check</code> displays more error messages than <code>nim c</code> and it can help finding the cause of an error.</p>
<h3>Using reserved words as identifiers</h3>
<p>You can use the slanted quote string syntax (stropping) if you need to use a reserved word as an identifier.</p>
<pre><code class="language-nim">var `type`: int
</code></pre>
<h3>Conditional compilation</h3>
<h4>Defining a compile time symbol</h4>
<p>You want to define <code>useSomeFeature</code> at compilation time and use it in the code.</p>
<ul>
<li>Do it when you compile: <code>$ nim c -d:useSomeFeature myApp</code></li>
<li>Put it in the <code>yourfilename.nims</code> file located in the same directory as your source file <code>yourfilename.nim</code> as <code>switch(&quot;define&quot;, &quot;useSomeFeature&quot;)</code></li>
<li>Put it in the <code>nim.cfg</code> file located in the same directory as source file and write <code>define:useSomeFeature</code></li>
</ul>
<pre><code class="language-nim">when defined(useSomeFeature):
  const someSubFeature = true
  type idType = int32
  var defaultUserName = &quot;Frank&quot;
else:
  type idType = int16
  var defaultUserName = &quot;Molly&quot;

# `when` does not open a new scope, so `idType` and `defaultUserName` are available here.

when isMainModule:
  # this code is ran only when this module is the main compilation module
  echo &quot;This module was compiled on &quot;, CompileDate, &quot; at &quot;, CompileTime
</code></pre>
<h3>Errors</h3>
<h4>Error: attempting to call routine: 'a'</h4>
<p>Nim likes spaces. This is a quirk of the command syntax where <code>a +b</code> is evaluated as <code>a(+(b))</code>.
Use spaces, preferably, like <code>a + b</code> or else <code>a+b</code>, but don't mix space and no-spaces usage.</p>
<h4>Error: expression '...' has no type (or is ambiguous)</h4>
<ul>
<li>Have you tried to <code>discard</code> the value from a proc that does not return any value?</li>
</ul>
<pre><code class="language-nim">proc noReturnValue =
  echo &quot;Foo!&quot;

discard noReturnValue()
</code></pre>
<h4>Error: '...' doesn't have a concrete type, due to unspecified generic parameters.</h4>
<ul>
<li>A inner proc &quot;inherits&quot; the including proc generics declaration and you don't need to re-define them.</li>
</ul>
<pre><code class="language-nim">proc foo[T](x: T) =
  proc bar[T](y: T) =    &lt;== Error is here
    echo &quot;In bar&quot;
  echo &quot;In foo&quot;
</code></pre>
<p>You must write:</p>
<pre><code class="language-nim">proc foo[T](x: T) =
  proc bar(y: T) =    # Generic type T is defined by englobing proc
    echo &quot;In bar&quot;
  echo &quot;In foo&quot;
</code></pre>
<h4>Error: undeclared field: 'major' for type foo.Version</h4>
<p>To access fields of a public object, these fields must be public too.</p>
<p>This is causing the error, where <code>Version</code> is defined in <code>foo.nim</code>:</p>
<pre><code class="language-nim">type
  Version* = object
    major: int
</code></pre>
<p>You must write:</p>
<pre><code class="language-nim">type
  Version* = object
    major*: int
</code></pre>
<h4>Error: template instantiation too nested</h4>
<p>Remember that templates replace template call with template body recursively. This can occur even in non-recursive templates in case of parameter clash. For instance:</p>
<pre><code class="language-nim">template foo(body: untyped) =
  template bar(body: untyped) =
    ...
</code></pre>
<p>Here the <code>body</code> parameter is not seen both by <code>foo</code> and <code>bar</code> as different symbols. When <code>foo</code> instantiates, it will replace the occurrence in <code>bar</code> parameters. To prevent the symbol name clash, you must write:</p>
<pre><code class="language-nim">template foo(fooBody: untyped) =
  template bar(barBody: untyped) =
    ...
</code></pre>
<h4>Error: identifier expected, but found '...</h4>
<p>See also <code>Error: template instantiation too nested</code></p>
<h4>Error: type mismatch: got &lt;X&gt; but expression is of type: X</h4>
<p>This can happen when a type is defined twice, probably because of a file <code>include</code>. This can occur too when you create duplicated types in macro code.</p>
<h4>Error: ambiguous call; both procName...</h4>
<p>You have forward declared <code>procName</code> to define recursive macro procs but the compiler complains that it found two declarations of <code>procName</code>. Additionally, there's a hint that <code>procName</code> is declared but not used!</p>
<p>This happens because the forward declaration does not <a href="https://github.com/nim-lang/Nim/issues/12175">use the same parameter names</a> as in the proc definition .</p>
<pre><code class="language-nim"># Forward declaration of procName that will cause a compile error.
# Use argument `stmt` instead of `arg` to have it compile.
proc procName(arg: NimNode): NimNode

proc procName(stmt: NimNode): NimNode =
  ...
</code></pre>
<h2>Tests</h2>
<h4>How to test that the compiler will reject a piece of code?</h4>
<p>Use <a href="https://nim-lang.org/docs/system.html#compiles%2Cuntyped">compiles</a>.</p>
<pre><code class="language-nim">import unittest

suite &quot;valid syntax&quot;:
  test &quot;syntax errors&quot;:
    let a = &quot;foo&quot;
    let b = 5
    assert not compiles(let c = a + b), &quot;Can't mix string and int&quot;
</code></pre>
<h4>Enhance documentation with examples</h4>
<p>You can provide examples of in your documentation, with <a href="https://nim-lang.org/docs/system.html#runnableExamples%2Cuntyped">runnableExamples</a>.
When the documentation is extracted from the source with <code>$ nim doc myfile.nim</code>, these examples are extracted and put in a temporary
file, compiled and tested. This is a good way to provide examples for your API and check that they are still valid.</p>
<pre><code class="language-nim">proc isOdd(i: int): bool =
  ## Test if its argument is odd.
  runnableExamples:
    assert 5.isOdd, &quot;5 is an odd number&quot;
    assert not isOdd(3 * 2), &quot;6 is not an odd number&quot;

  result = i mod 2 == 1
</code></pre>
<h2>Templates</h2>
<h4>Templates overloading</h4>
<p>Like proc or funct, template follow overloading rules. You can use normal types for parameters but they can have meta-types too: <code>typed</code>, <code>untyped</code> and <code>typedesc</code>.</p>
<p>There are <a href="https://nim-lang.org/docs/manual.html#overloading-resolution-lazy-type-resolution-for-untyped">lazy type resolution rules for <code>untyped</code></a> parameters.</p>
<p>For <code>typed</code> parameters, you can use <a href="https://nim-lang.org/docs/manual_experimental.html#term-rewriting-macros-parameter-constraints">parameter constraints</a> to reduce the scope of the parameters.</p>
<pre><code class="language-nim">template foo(x: typed{lit}) =
  echo &quot;foo matched the literal '&quot;, x, &quot;'&quot;

template foo(x: typed{ident}) =
  echo &quot;foo matched the identifier '&quot;, x, &quot;'&quot;
</code></pre>
<h4>Template scopes</h4>
<p>You have defined a <code>dsl:</code> and you want to define an <code>options:</code> template that can be used only within <code>dsl:</code>. How do you do this? Use <code>block:</code> scopes and <a href="https://nim-lang.org/docs/system.html#declaredInScope%2Cuntyped">declaredInScope</a>, like following:</p>
<pre><code class="language-nim">template dsl*(body: untyped) =
  block:
    const inDsl {.inject, used.} = true
    # Here define the dsl code...

template options(body: untyped) =
  when not declaredInScope(inDsl):
    {.fatal: &quot;`options` can be used only in `dsl` block&quot;.}
    # Here define the options code...
</code></pre>
<p>Don't try to create englobing templates! Templates are text code rewriting macros and you'll get unexpected results...</p>
<h2>Macros</h2>
<h4>Dump macro expansion</h4>
<p><a href="https://nim-lang.org/docs/macros.html#expandMacros.m%2Ctyped">expandMacros</a> shows how a macro call is expanded at compilation time. It's very useful for debugging macros...</p>
<p><a href="https://nim-lang.org/docs/macros.html#dumpTree.m%2Cuntyped">dumpTree</a> can also be used to print how a block of code is parsed at compile time.</p>
<pre><code class="language-nim">import macros

let x, y = (4, 8)
expandMacros:
  echo &quot;x &gt; y is expanded to &quot;, x &gt; y
dumpTree:
  echo &quot;x &gt; y is expanded to &quot;, x &gt; y
</code></pre>
<h2>Output</h2>
<h4>Echo to stderr</h4>
<p><code>echo</code> writes to <code>stdout</code>. If you want to print to <code>stderr</code> use <a href="https://nim-lang.org/docs/streams.html#write%2CStream%2Cvarargs%5Bstring%2C%5D">write</a> and <a href="https://nim-lang.org/docs/streams.html#writeLine%2CStream%2Cvarargs%5Bstring%2C%5D">writeLine</a></p>
<pre><code class="language-nim">writeLine(stderr, &quot;Write to stderr&quot;)
</code></pre>
<h4>How do I echo in a <code>{.noSideEffect.}</code> proc?</h4>
<p>You can use <a href="https://nim-lang.org/docs/system.html#debugEcho%2Cvarargs%5Btyped%2C%5D">debugEcho</a> for this.</p>
<h2>Enums</h2>
<h4>Converting string to enum</h4>
<p>Strings can be converted to enum using <a href="https://nim-lang.org/docs/strutils.html#parseEnum%2Cstring">parseEnum</a> from <a href="https://nim-lang.org/docs/strutils.html">strutils</a>. Beware that a <code>ValueError</code> is raised if the enum is not found. If you don't want to manage
the exception, provide a default with <a href="https://nim-lang.org/docs/strutils.html#parseEnum%2Cstring%2CT">parseEnum</a>.</p>
<pre><code class="language-nim">import strutils

type
  Fruit = enum
    Apple,
    Banana,
    Cherry

  let fruit = parseEnum[Fruit](&quot;cherry&quot;)
  let pineapple = parseEnum[Fruit](&quot;pineapple&quot;, Banana)
</code></pre>
<h2>Tuple</h2>
<h4>Enumerate the fields of a tuple or object.</h4>
<p><a href="https://nim-lang.org/docs/iterators.html#fields.i%2CS%2CT">fields</a> and <a href="https://nim-lang.org/docs/iterators.html#fieldPairs.i%2CT">fieldPairs</a> will help you discover the fields and values of a tuple or object. But as Nim is strongly type, you can't build a result mixing types. Either use conditional compilation for different code paths or use overloading.</p>
<pre><code class="language-nim">type
  Custom = object
    foo: string
    bar: bool

proc `$`(x: Custom): string =
  result = &quot;Custom:&quot;
  for name, value in x.fieldPairs:
    when value is bool:
      result.add(&quot;\n\t&quot; &amp; name &amp; &quot; is &quot; &amp; $value)
    else:
      result.add(&quot;\n\t&quot; &amp; name &amp; &quot; \'&quot; &amp; value &amp; &quot;\'&quot;)

proc `$1`(x: string): string = $x
proc `$1`(x: bool): string = $x

proc `$1`(x: Custom): string =
  result = &quot;Custom:&quot;
  for name, value in x.fieldPairs:
    result.add(&quot;\n\t&quot; &amp; name &amp; &quot; is &quot; &amp; `$1`(value))

let o = Custom(foo: &quot;Hi there!&quot;, bar: false)

echo &quot;o=&quot;, $o
echo &quot;o1=&quot;, `$1`(o)
</code></pre>
<h2>Seq and lists</h2>
<h4>Heterogeneous lists</h4>
<p>Nim being strongly typed, you can't mix multiple types in a <code>seq</code>. <a href="https://forum.nim-lang.org/t/4415">andrea</a> came out with heterogeneous lists that fit that special need:</p>
<pre><code class="language-nim"># hlist.nim

type
  HNil* = object
  HCons*[H, T] = ref object
    h: H
    t: T
  HList = HNil or HCons

let hNil* = HNil()

proc cons*[H; T: HList](hd: H; tl:T): auto =
  HCons[H, T](h: hd, t: tl)

template `&lt;&gt;`*(hd, tl: untyped): untyped = cons(hd, tl)

proc head*[H, T](c: HCons[H, T]): H {.inline.} = c.h

proc tail*[H, T](c: HCons[H, T]): T {.inline.} = c.t
</code></pre>
<p>They can be used like in this short example where <code>l</code> contains a <code>string</code> and an <code>int</code>.</p>
<pre><code class="language-nim">import hlist

proc printAll(n: HNil) =
  discard

proc printAll[H; T](hl: HCons[H, T]) =
  echo hl.head
  printAll(hl.tail)

let l = &quot;hi&quot; &lt;&gt; (2 &lt;&gt; hNil)
printAll(l)
</code></pre>
<h2>Iterators</h2>
<h3>Recursive iterators</h3>
<p>From a <a href="https://forum.nim-lang.org/t/7020">forum post</a> demonstrating how to simulate recursive iterator by converting a recursive proc to generate all character permutations of a string. This macro does not support <code>break</code> or <code>continue</code> statement, but read the referred <a href="https://forum.nim-lang.org/t/7020">post</a> to find more complete example.</p>
<pre><code class="language-nim">import std/macros

macro toItr*(x: ForLoopStmt): untyped =
    ## Convert factory proc call for inline-iterator-like usage.
    ## E.g.: ``for a,b in toItr(myFactory(parm)): echo a,b``.
    let
        forVars = x[0..^3]
        call    = x[^2][1] # Get foo out of toItr(foo)
        body    = x[^1]
        itrSym  = ident&quot;itr&quot;
        #itrSym  = genSym(ident=&quot;itr&quot;)
    var forTree = nnkForStmt.newTree()  # for
    for v in forVars: forTree.add v     # for v1,...
    forTree.add(nnkCall.newTree(itrSym), body) # for v1,... in itr(): body
    result = quote do:
        block:
            let `itrSym` {.inject.} = `call`
            `forTree`
    #debugEcho result.repr # uncomment to print the generated code

when isMainModule:
    proc lex_perm[T: seq|string](s: T, idxStart=0): iterator(): (T,int) =
        var idx= idxStart
        result = iterator(): (T,int) =
            if s.len == 0: yield (s[0..&lt;0], idx)
            for i in 0 ..&lt; s.len:
                for s2,_ in toItr lex_perm(s[0 ..&lt; i] &amp; s[i+1 .. ^1], idx):
                    yield (s[i ..&lt; i+1] &amp; s2, idx)
                    inc idx
    
    for s,idx in toItr lex_perm(&quot;123&quot;, 1): echo idx,&quot;:  &quot;,s
</code></pre>
<h2>External libraries</h2>
<h3>Managing external libraries memory allocations</h3>
<p>Some external libraries provide an API to give access to data structures that they allocated on their own. They also provide a reference counting process in order for the client code to manage when the library can release the memory or resources used by these data structures. The use of <a href="https://nim-lang.org/docs/destructors.html">destructors</a> and compiling with <code>--gc:arc</code> or <code>--gc:orc</code> can ease bridging to these API. In the following sample, <code>apiX()</code> are calls to the external library API.</p>
<pre><code class="language-nim">type
  MyObject* = object
    ## The Nim proxy object that is used in Nim code
    apiObject: pointer
      ## The pointer to the library object

proc initMyObject*: MyObject =
  ## Get a new library object.
  result = MyObject(apiObject: apiGetObject(...))
  # We increment the reference counter for this object
  apiIncRefCounter(apiObject)

proc `=destroy`(o: var MyObject) =
  ## When a ``MyObject`` is destroyed in Nim code, we need to decrement
  ## the API reference counter of that object.
  if not isNil(o.apiObject):
    apiDecRefCounter(o.apiObject)
    o.apiObject = nil

proc `=`(a: var MyObject; b: MyObject) =
  # Do nothing for self-assignments:
  if a.apiObject == b.apiObject:
    return

  # Destroy what is allocated in a
  `=destroy`(a)

  # Copy new content to a and increment reference counter
  if not isNil(b.apiObject):
    a.apiObject = b.apiObject
    apiIncRefCounter(a.apiObject)
</code></pre>
<p>Don't forget to compile with <code>--gc:arc</code> or <code>--gc:orc</code> to enable destructors. Notice how <code>MyObject</code> has public visibility while its <code>apiObject</code> field is kept private.</p>
<h2>Language details</h2>
<h4>Shallow vs. DeepCopy</h4>
<ul>
<li>https://forum.nim-lang.org/t/2665#16487</li>
</ul>
<h4>import vs include</h4>
<p><code>import</code> imports the public symbols (the ones with <code>*</code> after the name) from the imported module. You can't access the non-public symbols. <code>import</code> lines can be used only at the top level of a module.</p>
<p><code>include</code> replace the include line with the content of the included file. You can access public and non-public symbols as they are part of the code now. <code>include</code> is mainly used to break big Nim files into smaller ones. <code>include</code> statements are not limited to the top level of module. But <code>include</code> files can create strange error messages too (see Error: type mismatch: got &lt;X&gt; but expression is of type: X).</p>
<h2>Optimization via C compiler flags (LTO, PGO, ...)</h2>
<h4>Clang</h4>
<ul>
<li>https://forum.nim-lang.org/t/6295</li>
</ul>
</main>
<footer>
<hr>
<div class="nb-box">
  <span><span class="nb-small">made with <a href="https://pietroppeter.github.io/nimib/">nimib üê≥</a></span></span>
  <span></span>
  <span><button class="nb-small" id="show" onclick="toggleSourceDisplay()">Show Source</button></span>
</div>
</footer>
<section id="source">
<pre><code class="nim hljs"><span class="hljs-keyword">import</span> strformat, strutils
<span class="hljs-keyword">import</span> nimib
<span class="hljs-keyword">import</span> nimoji

nbInit

nbText:<span class="hljs-string">&quot;&quot;&quot;
# Nim Tips and tricks

A mix of bits of code, cookbook recipes, deep knowledge, tips and tricks about Nim programming.

## Compilation

### Syntax

#### Check syntax

Use `nim check myfile.nim` to check your program for errors, without code generation. This makes the process quicker. Also, `nim check` displays more error messages than `nim c` and it can help finding the cause of an error.

### Using reserved words as identifiers

You can use the slanted quote string syntax (stropping) if you need to use a reserved word as an identifier.

```nim
var `type`: int
```

### Conditional compilation

#### Defining a compile time symbol

You want to define `useSomeFeature` at compilation time and use it in the code.

* Do it when you compile: `$ nim c -d:useSomeFeature myApp`
* Put it in the `yourfilename.nims` file located in the same directory as your source file `yourfilename.nim` as `switch(&quot;define&quot;, &quot;useSomeFeature&quot;)`
* Put it in the `nim.cfg` file located in the same directory as source file and write `define:useSomeFeature`

```nim
when defined(useSomeFeature):
  const someSubFeature = true
  type idType = int32
  var defaultUserName = &quot;Frank&quot;
else:
  type idType = int16
  var defaultUserName = &quot;Molly&quot;

# `when` does not open a new scope, so `idType` and `defaultUserName` are available here.

when isMainModule:
  # this code is ran only when this module is the main compilation module
  echo &quot;This module was compiled on &quot;, CompileDate, &quot; at &quot;, CompileTime
```

### Errors

#### Error: attempting to call routine: 'a'

Nim likes spaces. This is a quirk of the command syntax where `a +b` is evaluated as `a(+(b))`.
Use spaces, preferably, like `a + b` or else `a+b`, but don't mix space and no-spaces usage.

#### Error: expression '...' has no type (or is ambiguous)

- Have you tried to `discard` the value from a proc that does not return any value?

```nim
proc noReturnValue =
  echo &quot;Foo!&quot;

discard noReturnValue()
```

#### Error: '...' doesn't have a concrete type, due to unspecified generic parameters.

- A inner proc &quot;inherits&quot; the including proc generics declaration and you don't need to re-define them.

```nim
proc foo[T](x: T) =
  proc bar[T](y: T) =    &lt;== Error is here
    echo &quot;In bar&quot;
  echo &quot;In foo&quot;
```
You must write:

```nim
proc foo[T](x: T) =
  proc bar(y: T) =    # Generic type T is defined by englobing proc
    echo &quot;In bar&quot;
  echo &quot;In foo&quot;
```

#### Error: undeclared field: 'major' for type foo.Version

To access fields of a public object, these fields must be public too.

This is causing the error, where ``Version`` is defined in ``foo.nim``:

```nim
type
  Version* = object
    major: int
```

You must write:

```nim
type
  Version* = object
    major*: int
```

#### Error: template instantiation too nested

Remember that templates replace template call with template body recursively. This can occur even in non-recursive templates in case of parameter clash. For instance:

```nim
template foo(body: untyped) =
  template bar(body: untyped) =
    ...
```

Here the ``body`` parameter is not seen both by ``foo`` and ``bar`` as different symbols. When ``foo`` instantiates, it will replace the occurrence in ``bar`` parameters. To prevent the symbol name clash, you must write:

```nim
template foo(fooBody: untyped) =
  template bar(barBody: untyped) =
    ...
```

#### Error: identifier expected, but found '...

See also `Error: template instantiation too nested`

#### Error: type mismatch: got &amp;lt;X&amp;gt; but expression is of type: X

This can happen when a type is defined twice, probably because of a file ``include``. This can occur too when you create duplicated types in macro code.

#### Error: ambiguous call; both procName...

You have forward declared `procName` to define recursive macro procs but the compiler complains that it found two declarations of `procName`. Additionally, there's a hint that `procName` is declared but not used!

This happens because the forward declaration does not [use the same parameter names](https://github.com/nim-lang/Nim/issues/12175) as in the proc definition .

```nim
# Forward declaration of procName that will cause a compile error.
# Use argument `stmt` instead of `arg` to have it compile.
proc procName(arg: NimNode): NimNode

proc procName(stmt: NimNode): NimNode =
  ...
```

## Tests

#### How to test that the compiler will reject a piece of code?

Use [compiles](https://nim-lang.org/docs/system.html#compiles%2Cuntyped).

```nim
import unittest

suite &quot;valid syntax&quot;:
  test &quot;syntax errors&quot;:
    let a = &quot;foo&quot;
    let b = 5
    assert not compiles(let c = a + b), &quot;Can't mix string and int&quot;
```

#### Enhance documentation with examples

You can provide examples of in your documentation, with [runnableExamples](https://nim-lang.org/docs/system.html#runnableExamples%2Cuntyped).
When the documentation is extracted from the source with `$ nim doc myfile.nim`, these examples are extracted and put in a temporary
file, compiled and tested. This is a good way to provide examples for your API and check that they are still valid.

```nim
proc isOdd(i: int): bool =
  ## Test if its argument is odd.
  runnableExamples:
    assert 5.isOdd, &quot;5 is an odd number&quot;
    assert not isOdd(3 * 2), &quot;6 is not an odd number&quot;

  result = i mod 2 == 1
```

## Templates

#### Templates overloading

Like proc or funct, template follow overloading rules. You can use normal types for parameters but they can have meta-types too: `typed`, `untyped` and `typedesc`.

There are [lazy type resolution rules for `untyped`](https://nim-lang.org/docs/manual.html#overloading-resolution-lazy-type-resolution-for-untyped) parameters.

For `typed` parameters, you can use [parameter constraints](https://nim-lang.org/docs/manual_experimental.html#term-rewriting-macros-parameter-constraints) to reduce the scope of the parameters.

```nim
template foo(x: typed{lit}) =
  echo &quot;foo matched the literal '&quot;, x, &quot;'&quot;

template foo(x: typed{ident}) =
  echo &quot;foo matched the identifier '&quot;, x, &quot;'&quot;
```

#### Template scopes

You have defined a `dsl:` and you want to define an `options:` template that can be used only within `dsl:`. How do you do this? Use `block:` scopes and [declaredInScope](https://nim-lang.org/docs/system.html#declaredInScope%2Cuntyped), like following:

```nim
template dsl*(body: untyped) =
  block:
    const inDsl {.inject, used.} = true
    # Here define the dsl code...

template options(body: untyped) =
  when not declaredInScope(inDsl):
    {.fatal: &quot;`options` can be used only in `dsl` block&quot;.}
    # Here define the options code...
```

Don't try to create englobing templates! Templates are text code rewriting macros and you'll get unexpected results...

## Macros

#### Dump macro expansion

[expandMacros](https://nim-lang.org/docs/macros.html#expandMacros.m%2Ctyped) shows how a macro call is expanded at compilation time. It's very useful for debugging macros...

[dumpTree](https://nim-lang.org/docs/macros.html#dumpTree.m%2Cuntyped) can also be used to print how a block of code is parsed at compile time.

```nim
import macros

let x, y = (4, 8)
expandMacros:
  echo &quot;x &gt; y is expanded to &quot;, x &gt; y
dumpTree:
  echo &quot;x &gt; y is expanded to &quot;, x &gt; y
```

## Output

#### Echo to stderr

`echo` writes to `stdout`. If you want to print to `stderr` use [write](https://nim-lang.org/docs/streams.html#write%2CStream%2Cvarargs%5Bstring%2C%5D) and [writeLine](https://nim-lang.org/docs/streams.html#writeLine%2CStream%2Cvarargs%5Bstring%2C%5D)

```nim
writeLine(stderr, &quot;Write to stderr&quot;)
```

#### How do I echo in a `{.noSideEffect.}` proc?

You can use [debugEcho](https://nim-lang.org/docs/system.html#debugEcho%2Cvarargs%5Btyped%2C%5D) for this.

## Enums

#### Converting string to enum

Strings can be converted to enum using [parseEnum](https://nim-lang.org/docs/strutils.html#parseEnum%2Cstring) from [strutils](https://nim-lang.org/docs/strutils.html). Beware that a `ValueError` is raised if the enum is not found. If you don't want to manage
the exception, provide a default with [parseEnum](https://nim-lang.org/docs/strutils.html#parseEnum%2Cstring%2CT).

```nim
import strutils

type
  Fruit = enum
    Apple,
    Banana,
    Cherry

  let fruit = parseEnum[Fruit](&quot;cherry&quot;)
  let pineapple = parseEnum[Fruit](&quot;pineapple&quot;, Banana)
```

## Tuple

#### Enumerate the fields of a tuple or object.

[fields](https://nim-lang.org/docs/iterators.html#fields.i%2CS%2CT) and [fieldPairs](https://nim-lang.org/docs/iterators.html#fieldPairs.i%2CT) will help you discover the fields and values of a tuple or object. But as Nim is strongly type, you can't build a result mixing types. Either use conditional compilation for different code paths or use overloading.

```nim
type
  Custom = object
    foo: string
    bar: bool

proc `$`(x: Custom): string =
  result = &quot;Custom:&quot;
  for name, value in x.fieldPairs:
    when value is bool:
      result.add(&quot;\n\t&quot; &amp; name &amp; &quot; is &quot; &amp; $value)
    else:
      result.add(&quot;\n\t&quot; &amp; name &amp; &quot; \'&quot; &amp; value &amp; &quot;\'&quot;)

proc `$1`(x: string): string = $x
proc `$1`(x: bool): string = $x

proc `$1`(x: Custom): string =
  result = &quot;Custom:&quot;
  for name, value in x.fieldPairs:
    result.add(&quot;\n\t&quot; &amp; name &amp; &quot; is &quot; &amp; `$1`(value))

let o = Custom(foo: &quot;Hi there!&quot;, bar: false)

echo &quot;o=&quot;, $o
echo &quot;o1=&quot;, `$1`(o)
```

## Seq and lists

#### Heterogeneous lists

Nim being strongly typed, you can't mix multiple types in a ``seq``. [andrea](https://forum.nim-lang.org/t/4415) came out with heterogeneous lists that fit that special need:

```nim
# hlist.nim

type
  HNil* = object
  HCons*[H, T] = ref object
    h: H
    t: T
  HList = HNil or HCons

let hNil* = HNil()

proc cons*[H; T: HList](hd: H; tl:T): auto =
  HCons[H, T](h: hd, t: tl)

template `&lt;&gt;`*(hd, tl: untyped): untyped = cons(hd, tl)

proc head*[H, T](c: HCons[H, T]): H {.inline.} = c.h

proc tail*[H, T](c: HCons[H, T]): T {.inline.} = c.t
```

They can be used like in this short example where ``l`` contains a ``string`` and an ``int``.

```nim
import hlist

proc printAll(n: HNil) =
  discard

proc printAll[H; T](hl: HCons[H, T]) =
  echo hl.head
  printAll(hl.tail)

let l = &quot;hi&quot; &lt;&gt; (2 &lt;&gt; hNil)
printAll(l)
```

## Iterators

### Recursive iterators

From a [forum post](https://forum.nim-lang.org/t/7020) demonstrating how to simulate recursive iterator by converting a recursive proc to generate all character permutations of a string. This macro does not support `break` or `continue` statement, but read the referred [post](https://forum.nim-lang.org/t/7020) to find more complete example.

```nim
import std/macros

macro toItr*(x: ForLoopStmt): untyped =
    ## Convert factory proc call for inline-iterator-like usage.
    ## E.g.: ``for a,b in toItr(myFactory(parm)): echo a,b``.
    let
        forVars = x[0..^3]
        call    = x[^2][1] # Get foo out of toItr(foo)
        body    = x[^1]
        itrSym  = ident&quot;itr&quot;
        #itrSym  = genSym(ident=&quot;itr&quot;)
    var forTree = nnkForStmt.newTree()  # for
    for v in forVars: forTree.add v     # for v1,...
    forTree.add(nnkCall.newTree(itrSym), body) # for v1,... in itr(): body
    result = quote do:
        block:
            let `itrSym` {.inject.} = `call`
            `forTree`
    #debugEcho result.repr # uncomment to print the generated code

when isMainModule:
    proc lex_perm[T: seq|string](s: T, idxStart=0): iterator(): (T,int) =
        var idx= idxStart
        result = iterator(): (T,int) =
            if s.len == 0: yield (s[0..&lt;0], idx)
            for i in 0 ..&lt; s.len:
                for s2,_ in toItr lex_perm(s[0 ..&lt; i] &amp; s[i+1 .. ^1], idx):
                    yield (s[i ..&lt; i+1] &amp; s2, idx)
                    inc idx
    
    for s,idx in toItr lex_perm(&quot;123&quot;, 1): echo idx,&quot;:  &quot;,s
```

## External libraries

### Managing external libraries memory allocations

Some external libraries provide an API to give access to data structures that they allocated on their own. They also provide a reference counting process in order for the client code to manage when the library can release the memory or resources used by these data structures. The use of [destructors](https://nim-lang.org/docs/destructors.html) and compiling with ``--gc:arc`` or ``--gc:orc`` can ease bridging to these API. In the following sample, ``apiX()`` are calls to the external library API.

```nim
type
  MyObject* = object
    ## The Nim proxy object that is used in Nim code
    apiObject: pointer
      ## The pointer to the library object

proc initMyObject*: MyObject =
  ## Get a new library object.
  result = MyObject(apiObject: apiGetObject(...))
  # We increment the reference counter for this object
  apiIncRefCounter(apiObject)

proc `=destroy`(o: var MyObject) =
  ## When a ``MyObject`` is destroyed in Nim code, we need to decrement
  ## the API reference counter of that object.
  if not isNil(o.apiObject):
    apiDecRefCounter(o.apiObject)
    o.apiObject = nil

proc `=`(a: var MyObject; b: MyObject) =
  # Do nothing for self-assignments:
  if a.apiObject == b.apiObject:
    return

  # Destroy what is allocated in a
  `=destroy`(a)

  # Copy new content to a and increment reference counter
  if not isNil(b.apiObject):
    a.apiObject = b.apiObject
    apiIncRefCounter(a.apiObject)
```

Don't forget to compile with ``--gc:arc`` or ``--gc:orc`` to enable destructors. Notice how ``MyObject`` has public visibility while its ``apiObject`` field is kept private.

## Language details

#### Shallow vs. DeepCopy

* https://forum.nim-lang.org/t/2665#16487

#### import vs include

``import`` imports the public symbols (the ones with `*` after the name) from the imported module. You can't access the non-public symbols. ``import`` lines can be used only at the top level of a module.

``include`` replace the include line with the content of the included file. You can access public and non-public symbols as they are part of the code now. ``include`` is mainly used to break big Nim files into smaller ones. ``include`` statements are not limited to the top level of module. But ``include`` files can create strange error messages too (see Error: type mismatch: got &amp;lt;X&amp;gt; but expression is of type: X).

## Optimization via C compiler flags (LTO, PGO, ...)

#### Clang

* https://forum.nim-lang.org/t/6295&quot;&quot;&quot;</span>
nbSave()
</code></pre>
</section><script>
function toggleSourceDisplay() {
  var btn = document.getElementById("show")
  var source = document.getElementById("source");
  if (btn.innerHTML=="Show Source") {
    btn.innerHTML = "Hide Source";
    source.style.display = "block";
  } else {
    btn.innerHTML = "Show Source";
    source.style.display = "none";
  }
}
</script></body>
</html>