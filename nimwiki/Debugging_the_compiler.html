<!DOCTYPE html>
<html lang="en-us">
<head>
  <title>nimwiki/Debugging_the_compiler.nim</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2280%22>üê≥</text></svg>">
  <meta content="text/html; charset=utf-8" http-equiv="content-type">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <link rel='stylesheet' href='https://unpkg.com/normalize.css'>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/light.min.css">
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/gh/pietroppeter/nimib/assets/atom-one-light.css'>
  <style>
.nb-box {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.nb-small {
  font-size: 0.8rem;
}
button.nb-small {
  float: right;
  padding: 2px;
  padding-right: 5px;
  padding-left: 5px;
}
section#source {
  display:none
}

.nb-output {
  line-height: 1.15;
}
</style>
  
</head>
<body>
<header>
<div class="nb-box">
  <span><a href="..">üè°</a></span>
  <span><code>nimwiki/Debugging_the_compiler.nim</code></span>
  <span><a href="https://github.com/dlesnoff/nim-wiki"><svg aria-hidden="true" width="1.2em" height="1.2em" style="vertical-align: middle;" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59c.4.07.55-.17.55-.38c0-.19-.01-.82-.01-1.49c-2.01.37-2.53-.49-2.69-.94c-.09-.23-.48-.94-.82-1.13c-.28-.15-.68-.52-.01-.53c.63-.01 1.08.58 1.23.82c.72 1.21 1.87.87 2.33.66c.07-.52.28-.87.51-1.07c-1.78-.2-3.64-.89-3.64-3.95c0-.87.31-1.59.82-2.15c-.08-.2-.36-1.02.08-2.12c0 0 .67-.21 2.2.82c.64-.18 1.32-.27 2-.27c.68 0 1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82c.44 1.1.16 1.92.08 2.12c.51.56.82 1.27.82 2.15c0 3.07-1.87 3.75-3.65 3.95c.29.25.54.73.54 1.48c0 1.07-.01 1.93-.01 2.2c0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z" fill="#000"></path></svg></a></span>
</div>
<hr>
</header><main>
<p>This page will provide some guidelines to those interested to work on the Nim compiler.</p>
<h3>How do I get started?</h3>
<p>The ongoing development of Nim happens primarily in our &quot;devel&quot; branch. To get started, follow the standard <a href="https://github.com/nim-lang/Nim#compiling">compilation instructions</a>, but make sure to check out the devel branch.</p>
<p>Most of the compiler code is stored in the <a href="https://github.com/nim-lang/Nim/tree/devel/compiler">compiler</a> directory and the individual modules are briefly described <a href="https://github.com/nim-lang/Nim/wiki/Compiler-module-reference">here</a>. After making any modifications, you can execute <code>koch boot -d:release</code> again to execute a full bootstrap cycle with your new code.</p>
<p>The build outputs will be stored in the &quot;bin&quot; directory of the repo. If you are using a Unix-like system, you can just create links to the executables stored there in a system folder such as <code>/usr/local/bin</code>. On Windows, you may want to add the bin directory to your PATH.</p>
<h3>Building a debug version of the compiler</h3>
<p>Executing <code>koch boot</code> after every change is unnecessarily slow and sometimes it's useful to keep a stable and fast version of the nim compiler while working on a debug build that may feature changes preventing the compiler from bootstrapping properly. That's why it's preferable to build a separate &quot;nimd&quot; executable and use it while testing your newly developed code.</p>
<p>To help you with this, we recommend that you add the following helper commands to your shell's profile file:</p>
<pre><code class="language-bash">NIM_REPO_DIR=&quot;$(dirname &quot;$(realpath &quot;$(which nim)&quot;)&quot;)/..&quot;

impl-nim-build () {
  local PREVDIR=`pwd`
  cd $NIM_REPO_DIR
  $NIM_BIN c $NIM_FLAGS $* compiler/nim.nim &amp;&amp; cp compiler/nim ./bin/$NIM_OUT
  local RES=$?
  cd $PREVDIR
  return $RES
}

nimd-build () {
  NIM_BIN=nim NIM_FLAGS=&quot;-d:debug&quot; NIM_OUT=nimd impl-nim-build $*
  return $?
}

nimd-boot () {
  NIM_BIN=nimd NIM_FLAGS=&quot;-d:debug&quot; NIM_OUT=nimd impl-nim-build $*
  return $?
}

nimd-linedir-build () {
  nimd-build --lineDir:on $*
}

nim-boot () {
  local PREVDIR=`pwd`
  cd $NIM_REPO_DIR
  ./koch boot -d:release $*
  local RES=$?
  cd $PREVDIR
  return $RES
}
</code></pre>
<p>Once having those, the typical workflow for testing a new change would be to execute:</p>
<pre><code>$ nimd-build &amp;&amp; nimd c my_test_module.nim
</code></pre>
<p>Obviously, the above assumes that &quot;nimd&quot; was also linked in &quot;/usr/local/bin&quot; or added to your PATH.</p>
<h3>Printf debugging</h3>
<p>&quot;Printf debugging&quot; is still the most appropriate way to debug many problems arising in compiler development. The typical usage of break points to debug the code is often less practical, because almost all of the code paths in the compiler will be executed hundreds of times before a particular section of the tested program is reached where the newly developed code must be activated.</p>
<p>To work-around this problem, you'll typically introduce an if statement in the compiler code detecting more precisely the conditions where the tested feature is being used. One very common way to achieve this is to use the <code>mdbg</code> condition, which will be true only in contexts, processing expressions and statements from the currently compiled main module.</p>
<pre><code class="language-nimrod">if mdbg:
  debug someAstNode
</code></pre>
<p>The above example also makes use of the <code>debug</code> proc, which is able to print a human-readable form of an arbitrary AST tree. Other common ways to print information about the internal compiler types include:</p>
<pre><code class="language-nimrod">echo renderTree(someNode)  # pretty prints the nimrod ast
debug(someNode)  # outputs some JSON representation
echo typeToString(someType) # pretty prints some type
debug(someType)
echo symbol.name.s
debug(symbol)
echo renderTree(someNode, {renderIds})  # pretty prints the nimrod ast, but annotates symbol IDs
if n.info ?? &quot;temp.nim&quot;:  echo renderTree(n)  # only output when it comes from &quot;temp.nim&quot;
if n.info ?? &quot;temp.nim&quot;:  writeStackTrace()  # why does it process temp.nim here?
</code></pre>
<h3>Using a C debugger</h3>
<p>The &quot;nimd&quot; executable is compiled with debugging information available and you can launch it under any command-line debugger as a normal C program. With a little bit of additional work, you can also setup projects in many graphical debuggers and IDEs.</p>
<p>The author of this guide mostly uses QtCreator for this, but if you use a different environment and you have certain tricks to share, please expand this section.</p>
<h3>Using a C debugger with line directives</h3>
<p>If you use the <code>nimd-linedir-build</code> command to build &quot;nimd&quot;, your debugger will be able to map the debugged code to the original Nim source files for a more natural debugging experience. At the moment, this capability is still quite rough on the edges.</p>
<h3>Using Mozilla rr</h3>
<p>Mozilla's rr is a powerful debugger that allows you to freely move backwards and forwards in a pre-recorded execution of nimd to more easily investigate problems. This section will be expanded in the future.</p>
<h3>Using the embedded debugger</h3>
<p>Using the Nim's <a href="https://nim-lang.org/docs/endb.html">embedded debugger</a> is not supported at the moment for debugging nimd, but this may be improved in the future.</p>
<h3>Running the test suite</h3>
<p>After your code starts working for simple examples in nimd, you'll want to test if it's also safe for bootstrapping. You can execute <code>nimd-boot</code> which will try to bootstrap the compiler using <code>nimd</code> itself. If this works without problems, you can execute <code>nim-boot</code> to bootstrap a new release version of the compiler incorporating your new changes.</p>
<p>At this point, you may also want to run the test suite in order to catch other possible regressions in more complicated snippets of code (in general, the compiler is conservative with regard to the Nim features it puts to use). You can do this by executing</p>
<pre><code class="language-bash">cd $NIM_REPO_DIR
./koch test
</code></pre>
<p>Running the full test suite is likely to take up to an hour on a modern computer, so sometimes you'll want to test only particular &quot;category&quot; of tests (categories are represented as sub-directories under tests/ in repo). You can do this by executing:</p>
<pre><code class="language-bash">./koch test c objects
</code></pre>
<h3>Creating a pull request</h3>
<p>Once you are sufficiently happy with your test results, please commit your changes to a feature branch and create a pull request on GitHub. This will subject your code to a more comprehensive test procedures on multiple operating systems and if new problems are discovered, you'll see a detailed log in your pull request.</p>
</main>
<footer>
<hr>
<div class="nb-box">
  <span><span class="nb-small">made with <a href="https://pietroppeter.github.io/nimib/">nimib üê≥</a></span></span>
  <span></span>
  <span><button class="nb-small" id="show" onclick="toggleSourceDisplay()">Show Source</button></span>
</div>
</footer>
<section id="source">
<pre><code class="nim hljs"><span class="hljs-keyword">import</span> strformat, strutils
<span class="hljs-keyword">import</span> nimib
<span class="hljs-keyword">import</span> nimoji

nbInit

nbText:<span class="hljs-string">&quot;&quot;&quot;
This page will provide some guidelines to those interested to work on the Nim compiler.

### How do I get started?

The ongoing development of Nim happens primarily in our &quot;devel&quot; branch. To get started, follow the standard [compilation instructions](https://github.com/nim-lang/Nim#compiling), but make sure to check out the devel branch.

Most of the compiler code is stored in the [compiler](https://github.com/nim-lang/Nim/tree/devel/compiler) directory and the individual modules are briefly described [here](https://github.com/nim-lang/Nim/wiki/Compiler-module-reference). After making any modifications, you can execute `koch boot -d:release` again to execute a full bootstrap cycle with your new code.

The build outputs will be stored in the &quot;bin&quot; directory of the repo. If you are using a Unix-like system, you can just create links to the executables stored there in a system folder such as `/usr/local/bin`. On Windows, you may want to add the bin directory to your PATH.

### Building a debug version of the compiler

Executing `koch boot` after every change is unnecessarily slow and sometimes it's useful to keep a stable and fast version of the nim compiler while working on a debug build that may feature changes preventing the compiler from bootstrapping properly. That's why it's preferable to build a separate &quot;nimd&quot; executable and use it while testing your newly developed code.

To help you with this, we recommend that you add the following helper commands to your shell's profile file:

``` bash
NIM_REPO_DIR=&quot;$(dirname &quot;$(realpath &quot;$(which nim)&quot;)&quot;)/..&quot;

impl-nim-build () {
  local PREVDIR=`pwd`
  cd $NIM_REPO_DIR
  $NIM_BIN c $NIM_FLAGS $* compiler/nim.nim &amp;&amp; cp compiler/nim ./bin/$NIM_OUT
  local RES=$?
  cd $PREVDIR
  return $RES
}

nimd-build () {
  NIM_BIN=nim NIM_FLAGS=&quot;-d:debug&quot; NIM_OUT=nimd impl-nim-build $*
  return $?
}

nimd-boot () {
  NIM_BIN=nimd NIM_FLAGS=&quot;-d:debug&quot; NIM_OUT=nimd impl-nim-build $*
  return $?
}

nimd-linedir-build () {
  nimd-build --lineDir:on $*
}

nim-boot () {
  local PREVDIR=`pwd`
  cd $NIM_REPO_DIR
  ./koch boot -d:release $*
  local RES=$?
  cd $PREVDIR
  return $RES
}
```

Once having those, the typical workflow for testing a new change would be to execute:

```
$ nimd-build &amp;&amp; nimd c my_test_module.nim
```

Obviously, the above assumes that &quot;nimd&quot; was also linked in &quot;/usr/local/bin&quot; or added to your PATH.

### Printf debugging

&quot;Printf debugging&quot; is still the most appropriate way to debug many problems arising in compiler development. The typical usage of break points to debug the code is often less practical, because almost all of the code paths in the compiler will be executed hundreds of times before a particular section of the tested program is reached where the newly developed code must be activated.

To work-around this problem, you'll typically introduce an if statement in the compiler code detecting more precisely the conditions where the tested feature is being used. One very common way to achieve this is to use the `mdbg` condition, which will be true only in contexts, processing expressions and statements from the currently compiled main module.

``` nimrod
if mdbg:
  debug someAstNode
```

The above example also makes use of the `debug` proc, which is able to print a human-readable form of an arbitrary AST tree. Other common ways to print information about the internal compiler types include:

```nimrod
echo renderTree(someNode)  # pretty prints the nimrod ast
debug(someNode)  # outputs some JSON representation
echo typeToString(someType) # pretty prints some type
debug(someType)
echo symbol.name.s
debug(symbol)
echo renderTree(someNode, {renderIds})  # pretty prints the nimrod ast, but annotates symbol IDs
if n.info ?? &quot;temp.nim&quot;:  echo renderTree(n)  # only output when it comes from &quot;temp.nim&quot;
if n.info ?? &quot;temp.nim&quot;:  writeStackTrace()  # why does it process temp.nim here?
```

### Using a C debugger

The &quot;nimd&quot; executable is compiled with debugging information available and you can launch it under any command-line debugger as a normal C program. With a little bit of additional work, you can also setup projects in many graphical debuggers and IDEs.

The author of this guide mostly uses QtCreator for this, but if you use a different environment and you have certain tricks to share, please expand this section.

### Using a C debugger with line directives

If you use the `nimd-linedir-build` command to build &quot;nimd&quot;, your debugger will be able to map the debugged code to the original Nim source files for a more natural debugging experience. At the moment, this capability is still quite rough on the edges.

### Using Mozilla rr

Mozilla's rr is a powerful debugger that allows you to freely move backwards and forwards in a pre-recorded execution of nimd to more easily investigate problems. This section will be expanded in the future.

### Using the embedded debugger

Using the Nim's [embedded debugger](https://nim-lang.org/docs/endb.html) is not supported at the moment for debugging nimd, but this may be improved in the future.

### Running the test suite

After your code starts working for simple examples in nimd, you'll want to test if it's also safe for bootstrapping. You can execute `nimd-boot` which will try to bootstrap the compiler using `nimd` itself. If this works without problems, you can execute `nim-boot` to bootstrap a new release version of the compiler incorporating your new changes.

At this point, you may also want to run the test suite in order to catch other possible regressions in more complicated snippets of code (in general, the compiler is conservative with regard to the Nim features it puts to use). You can do this by executing

```bash
cd $NIM_REPO_DIR
./koch test
```

Running the full test suite is likely to take up to an hour on a modern computer, so sometimes you'll want to test only particular &quot;category&quot; of tests (categories are represented as sub-directories under tests/ in repo). You can do this by executing:

``` bash
./koch test c objects
```

### Creating a pull request

Once you are sufficiently happy with your test results, please commit your changes to a feature branch and create a pull request on GitHub. This will subject your code to a more comprehensive test procedures on multiple operating systems and if new problems are discovered, you'll see a detailed log in your pull request.
&quot;&quot;&quot;</span>
nbSave()
</code></pre>
</section><script>
function toggleSourceDisplay() {
  var btn = document.getElementById("show")
  var source = document.getElementById("source");
  if (btn.innerHTML=="Show Source") {
    btn.innerHTML = "Hide Source";
    source.style.display = "block";
  } else {
    btn.innerHTML = "Show Source";
    source.style.display = "none";
  }
}
</script></body>
</html>